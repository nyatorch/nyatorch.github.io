{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"nyatorch's Wiki \u00b6 \u53c2\u8003 Noodlefighter \u7684\u6559\u7a0b\u7167\u846b\u82a6\u753b\u74e2\u642d\u8d77\u6765\u7684 Wiki\uff0c\u7528\u6765\u5f53\u7b14\u8bb0\u672c\u7528\u4e86\u3002\u6709\u5907\u4efd\u9700\u8981\u7684\u6587\u7ae0\u53ef\u80fd\u4e5f\u4f1a\u653e\u5728\u8fd9\u91cc\u3002","title":"nyatorch's Wiki"},{"location":"#nyatorchs-wiki","text":"\u53c2\u8003 Noodlefighter \u7684\u6559\u7a0b\u7167\u846b\u82a6\u753b\u74e2\u642d\u8d77\u6765\u7684 Wiki\uff0c\u7528\u6765\u5f53\u7b14\u8bb0\u672c\u7528\u4e86\u3002\u6709\u5907\u4efd\u9700\u8981\u7684\u6587\u7ae0\u53ef\u80fd\u4e5f\u4f1a\u653e\u5728\u8fd9\u91cc\u3002","title":"nyatorch's Wiki"},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA/Web%20%E5%BC%80%E5%8F%91/%E5%BB%BA%E7%AB%99/","text":"","title":"\u5efa\u7ad9"},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/","text":"","title":"Linux"},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/","text":"C \u00b6 \u6765\u6e90 Learn X in Y minutes // \u5355\u884c\u6ce8\u91ca\u4ee5 // \u5f00\u59cb\uff0c\u4ec5\u9002\u7528\u4e8eC99\u53ca\u4ee5\u540e\u3002 /* \u591a\u884c\u6ce8\u91ca\u770b\u8d77\u6765\u50cf\u8fd9\u6837\uff0c\u5bf9\u4e8e C89 \u4e5f\u9002\u7528 */ /* \u591a\u884c\u6ce8\u91ca\u4e0d\u80fd\u88ab\u5d4c\u5957 /* \u52a1\u5fc5\u5c0f\u5fc3 */ // \u8fd9\u6761\u6ce8\u91ca\u5728\u8fd9\u4e00\u884c\u5c31\u7ec8\u6b62\u4e86 */ // \u800c\u4e0d\u662f\u8fd9\u4e00\u884c\uff01 // \u5e38\u91cf\uff1a #define <\u5173\u952e\u5b57> // \u5e38\u91cf\u5b8c\u5168\u5199\u6210\u5927\u5199\u5b57\u6bcd\u662f\u60ef\u4f8b\uff0c\u4e0d\u662f\u5fc5\u987b\u7684\u8981\u6c42 #define DAYS_IN_YEAR 365 // \u679a\u4e3e\u5e38\u91cf\u4e5f\u662f\u58f0\u660e\u5e38\u91cf\u7684\u65b9\u6cd5\u3002 // \u6240\u6709\u7684\u8bed\u53e5\u5fc5\u987b\u4ee5\u5206\u53f7\u7ed3\u675f\u3002 enum days {SUN, MON, TUE, WED, THU, FRI, SAT}; // SUN \u88ab\u8d4b\u503c\u4e3a 0, MON \u88ab\u8d4b\u503c\u4e3a 1, TUE \u88ab\u8d4b\u503c\u4e3a 2, \u4ee5\u6b64\u7c7b\u63a8. // \u679a\u4e3e\u7684\u503c\u662f\u53ef\u4ee5\u88ab\u6307\u5b9a\u7684 enum days {SUN = 1, MON, TUE, WED = 99, THU, FRI, SAT}; // MON \u88ab\u81ea\u52a8\u8d4b\u503c\u4e3a 2, TUE \u88ab\u8d4b\u503c\u4e3a 3, \u4ee5\u6b64\u7c7b\u63a8. // WED \u88ab\u8d4b\u503c\u4e3a 99, THU \u88ab\u8d4b\u503c\u4e3a 100, FRI \u88ab\u8d4b\u503c\u4e3a 101, \u4ee5\u6b64\u7c7b\u63a8. // \u4f7f\u7528 #include \u5bfc\u5165\u5934\u6587\u4ef6 #include <stdlib.h> #include <stdio.h> #include <string.h> // \u5728<\u5c16\u62ec\u53f7>\u4e4b\u95f4\u7684\u6587\u4ef6\u540d\u544a\u8bc9\u7f16\u8bd1\u5668\u8981\u5728\u4f60\u7684\u7cfb\u7edf\u4e2d\u5bfb\u627e // \u5e93\u6216\u8005\u5934\u6587\u4ef6 // \u5bf9\u4e8e\u4f60\u81ea\u5df1\u7684\u5934\u6587\u4ef6\uff0c\u5e94\u8be5\u4f7f\u7528\u53cc\u5f15\u53f7\u800c\u4e0d\u662f\u5c16\u62ec\u53f7\uff0c\u4e14 // \u5e94\u8be5\u63d0\u4f9b\u8def\u5f84 #include \"my_header.h\" // \u672c\u5730\u6587\u4ef6 #include \"../my_lib/my_lib_header.h\" //\u76f8\u5bf9\u8def\u5f84 // \u5728 .h \u6587\u4ef6\u4e2d\u63d0\u524d\u58f0\u660e\u51fd\u6570\u7b7e\u540di\u6216\u8005 // \u5728\u4f60 .c \u6587\u4ef6\u7684\u4e0a\u65b9 void function_1(); int function_2(void); // \u81f3\u5c11\uff0c\u4f60\u5fc5\u987b\u5728\u4efb\u4f55\u51fd\u6570\u4e2d\u4f7f\u7528 \"\u51fd\u6570\u539f\u578b \"\u4e4b\u524d\u58f0\u660e\u5b83\u3002 // \u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u539f\u578b\u88ab\u653e\u7f6e\u5728\u6587\u4ef6\u7684\u9876\u90e8\uff0c\u5728\u4efb\u4f55\u51fd\u6570\u5b9a\u4e49\u4e4b\u524d\u3002 int add_two_ints(int x1, int x2); // function prototype // \u5c3d\u7ba1`int add_two_ints(int, int);`\u4e5f\u662f\u6709\u6548\u7684\uff08\u4e0d\u9700\u8981\u7ed9\u53c2\u6570\u547d\u540d\uff09\u3002 // \u5efa\u8bae\u5728\u539f\u578b\u4e2d\u4e5f\u4e3a\u53c2\u6570\u547d\u540d\uff0c\u4ece\u800c\u65b9\u4fbf\u68c0\u67e5\u3002 // \u5982\u679c\u51fd\u6570\u5b9a\u4e49\u5728\u8c03\u7528\u8be5\u51fd\u6570\u7684\u4efb\u4f55\u5176\u4ed6\u51fd\u6570\u4e4b\u524d // \u90a3\u4e48\u51fd\u6570\u539f\u578b\u5c31\u4e0d\u662f\u5fc5\u987b\u7684\u3002\u7136\u800c\uff0c\u6807\u51c6\u7684\u505a\u6cd5\u662f // \u59cb\u7ec8\u5c06\u51fd\u6570\u539f\u578b\u6dfb\u52a0\u5230\u5934\u6587\u4ef6(*.h)\u4e2d\uff0c\u7136\u540e\u5728\u5934\u6587\u4ef6\u4e2d#include\u8be5\u6587\u4ef6\u3002 // \u8fd9\u53ef\u4ee5\u9632\u6b62\u5728\u7f16\u8bd1\u5668\u77e5\u9053\u4e00\u4e2a\u51fd\u6570\u7684\u540d\u5b57\u4e4b\u524d\uff0c\u8be5\u51fd\u6570\u5c31\u88ab\u8c03\u7528\u7684\u95ee\u9898\u3002 // \u9664\u6b64\u4e4b\u5916\uff0c\u5b83\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5e72\u51c0\u7684\u5934\u6587\u4ef6 // \u4ece\u800c\u53ef\u4ee5\u548c\u9879\u76ee\u7684\u5176\u4ed6\u90e8\u5206\u5171\u4eab // \u4f60\u7684\u7a0b\u5e8f\u7684\u5165\u53e3\u662f\u4e00\u4e2a main \u51fd\u6570\uff0c\u5b83\u7684\u8fd4\u56de\u7c7b\u578b\u53ef\u4ee5\u4e3a\u4efb\u610f\u7c7b\u578b // \u7136\u800c\uff0c\u591a\u6570\u64cd\u4f5c\u7cfb\u7edf\u5e0c\u671b\u5b83\u7684\u8fd4\u56de\u503c\u4e3a int \u7c7b\u578b\uff0c\u4ece\u800c // \u7528\u4e8e\u5904\u7406\u9519\u8bef\u4ee3\u7801 int main(void) { // your program } // \u7528\u4e8e\u8fd0\u884c\u4f60\u7684\u7a0b\u5e8f\u7684\u547d\u4ee4\u884c\u53c2\u6570\u4e5f\u88ab\u4f20\u9012\u7ed9 main // argc\u662f\u53c2\u6570\u7684\u6570\u91cf--\u4f60\u7684\u7a0b\u5e8f\u540d\u79f0\u7b97\u4f5c 1 // argv\u662f\u4e00\u4e2a\u5b57\u7b26\u6570\u7ec4--\u5305\u542b\u53c2\u6570\u672c\u8eab // argv[0] = \u4f60\u7684\u7a0b\u5e8f\u540d\u79f0\uff0cargv[1] = \u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u4ee5\u6b64\u7c7b\u63a8 int main (int argc, char** argv) { // \u6253\u5370\u8f93\u51fa\u4f7f\u7528 printf \u610f\u601d\u662f\"\u683c\u5f0f\u5316\u6253\u5370\" // %d \u4ee3\u8868\u6574\u6570, \\n \u4ee3\u8868\u6362\u884c printf(\"%d\\n\", 0); // => \u6253\u5370 0 /////////////////////////////////////// // \u7c7b\u578b /////////////////////////////////////// // \u4e0d\u7b26\u5408 C99 \u6807\u51c6\u7684\u7f16\u8bd1\u5668\u8981\u6c42\u53d8\u91cf\u5fc5\u987b\u5728\u5f53\u524d\u5757\u8303\u56f4\u7684\u9876\u90e8\u58f0\u660e // \u7b26\u5408 C99 \u6807\u51c6\u7684\u7f16\u8bd1\u5668\u5141\u8bb8\u5728\u4f7f\u7528\u6570\u503c\u7684\u5730\u65b9\u8fdb\u884c\u58f0\u660e // \u5728\u672c\u6559\u7a0b\u4e2d\uff0c\u53d8\u91cf\u5728\u7b26\u5408 C99 \u6807\u51c6\u7684\u60c5\u51b5\u4e0b\u662f\u52a8\u6001\u58f0\u660e\u7684\u3002 // int\u578b\uff08\u6574\u578b\uff09\u53d8\u91cf\u4e00\u822c\u5360\u7528 4 \u4e2a\u5b57\u8282 (\u4f7f\u7528`sizeof`\u8fd0\u7b97\u7b26\u53ef\u4ee5\u68c0\u67e5) int x_int = 0; // short\u578b\uff08\u77ed\u6574\u578b\uff09\u53d8\u91cf\u4e00\u822c\u5360\u7528 2 \u4e2a\u5b57\u8282 (\u4f7f\u7528`sizeof`\u8fd0\u7b97\u7b26\u53ef\u4ee5\u68c0\u67e5) short x_short = 0; // \u5b57\u7b26\u7c7b\u578b\u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u5904\u7406\u5668\u7684\u6700\u5c0f\u53ef\u5bfb\u5740\u5355\u4f4d\u3002 // \u901a\u5e38\u662f 1 \u4e2a\u5b57\u8282, \u4f46\u5728\u67d0\u4e9b\u7cfb\u7edf\u4e2d\u5b83\u53ef\u4ee5\u66f4\u591a (\u4f8b\u5982\uff0c\u5728\u5fb7\u5dde\u4eea\u5668\u7684 TMS320 \u4e2d\u5b83\u662f 2 \u4e2a\u5b57\u8282). char x_char = 0; char y_char = 'y'; // \u5b57\u7b26\u53d8\u91cf\u7684\u5b57\u9762\u503c\u9700\u8981\u7528\u5355\u5f15\u53f7\u5305\u4f4f // long\u578b\uff08\u957f\u6574\u578b\uff09\u4e00\u822c\u9700\u8981 4 \u4e2a\u5b57\u8282\u5230 8 \u4e2a\u5b57\u8282; \u800clong long\u578b\u5219\u81f3\u5c11\u9700\u8981\u4fdd\u8bc1\u6709 8 \u4e2a\u5b57\u8282\uff0864 \u4f4d\uff09 long x_long = 0; long long x_long_long = 0; // float\u4e00\u822c\u662f\u7528 32 \u4f4d\u8868\u793a\u7684\u6d6e\u70b9\u6570\u5b57 float x_float = 0.0f; // 'f' suffix here denotes floating point literal // double\u4e00\u822c\u662f\u7528 64 \u4f4d\u8868\u793a\u7684\u6d6e\u70b9\u6570\u5b57 double x_double = 0.0; // real numbers without any suffix are doubles // \u6574\u6570\u7c7b\u578b\u4e5f\u53ef\u4ee5\u6709\u65e0\u7b26\u53f7\u7684\u7c7b\u578b\u8868\u793a\u3002\u8fd9\u6837\u8fd9\u4e9b\u53d8\u91cf\u5c31\u65e0\u6cd5\u8868\u793a\u8d1f\u6570 // \u4f46\u662f\u65e0\u7b26\u53f7\u6574\u6570\u6240\u80fd\u8868\u793a\u7684\u8303\u56f4\u5c31\u53ef\u4ee5\u6bd4\u539f\u6765\u7684\u6574\u6570\u5927\u4e00\u4e9b unsigned short ux_short; unsigned int ux_int; unsigned long long ux_long_long; // \u5355\u5f15\u53f7\u5185\u7684\u5b57\u7b26\u662f\u673a\u5668\u7684\u5b57\u7b26\u96c6\u4e2d\u7684\u6574\u6570\u3002 '0' // => \u5728 ASCII \u5b57\u7b26\u96c6\u4e2d\u662f 48 'A' // => \u5728 ASCII \u5b57\u7b26\u96c6\u4e2d\u662f 65 // sizeof(T) \u7ed9\u51fa\u4e86\u7c7b\u578b\u4e3aT\u7684\u53d8\u91cf\u7684\u5927\u5c0f\uff0c\u5355\u4f4d\u4e3a\u5b57\u8282\u3002 // sizeof(obj) \u4ea7\u751f\u8868\u8fbe\u5f0f\uff08\u53d8\u91cf\u3001\u5b57\u9762\u610f\u4e49\u7b49\uff09\u7684\u5927\u5c0f\u3002 printf(\"%zu\\n\", sizeof(int)); // => 4 (\u5728\u591a\u6570 4 \u5b57\u8282\u5b57\u957f\u7684\u673a\u5668\u4e0a) // \u5982\u679c`sizeof`\u7684\u53c2\u6570\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u90a3\u4e48\u8fd9\u4e2a\u53c2\u6570\u4e0d\u4f1a\u88ab\u6f14\u7b97\uff08VLA\u4f8b\u5916\uff0c\u89c1\u4e0b\uff09 // \u5b83\u4ea7\u751f\u7684\u503c\u662f\u7f16\u8bd1\u65f6\u7684\u5e38\u91cf int a = 1; // size_t\u662f\u4e00\u4e2a\u65e0\u7b26\u53f7\u6574\u578b\uff0c\u8868\u793a\u5bf9\u8c61\u7684\u5c3a\u5bf8\uff0c\u81f3\u5c11 2 \u4e2a\u5b57\u8282 size_t size = sizeof(a++); // a++ \u4e0d\u4f1a\u88ab\u6f14\u7b97 printf(\"sizeof(a++) = %zu where a = %d\\n\", size, a); // \u6253\u5370 \"sizeof(a++) = 4 where a = 1\" \uff08\u572832\u4f4d\u67b6\u6784\u4e0a\uff09 // \u6570\u7ec4\u5fc5\u987b\u88ab\u521d\u59cb\u5316\u4e3a\u5177\u4f53\u7684\u957f\u5ea6 char my_char_array[20]; // \u8fd9\u4e2a\u6570\u7ec4\u5360\u636e 1 * 20 = 20 \u5b57\u8282 int my_int_array[20]; // \u8fd9\u4e2a\u6570\u7ec4\u5360\u636e 4 * 20 = 80 \u5b57\u8282 // (\u5047\u8bbe\u4e3a 4 \u5b57\u8282\u5b57\u957f) // \u4f60\u53ef\u4ee5\u5c06\u4e00\u4e2a\u6570\u7ec4\u521d\u59cb\u5316\u4e3a\u96f6: char my_array[20] = {0}; // \u5176\u4e2d\"{0}\"\u90e8\u5206\u88ab\u79f0\u4e3a \"\u6570\u7ec4\u521d\u59cb\u5316\u5668\"\u3002 // \u6ce8\u610f\uff0c\u5982\u679c\u4f60\u5728\u540c\u4e00\u884c\u4e2d\u521d\u59cb\u5316\u6570\u7ec4 // \u4f60\u5c31\u53ef\u4ee5\u4e0d\u660e\u786e\u5730\u58f0\u660e\u6570\u7ec4\u7684\u5927\u5c0f\u3002 // \u6240\u4ee5\uff0c\u4e0b\u9762\u7684\u58f0\u660e\u4e5f\u662f\u5408\u6cd5\u7684\u3002 char my_array[] = {0}; // \u4f46\u662f\uff0c\u7136\u540e\u4f60\u5fc5\u987b\u5728\u8fd0\u884c\u65f6\u8bc4\u4f30\u6570\u7ec4\u7684\u5927\u5c0f\uff0c\u50cf\u8fd9\u6837: size_t my_array_size = sizeof(my_array) / sizeof(my_array[0]); // \u8b66\u544a \u5982\u679c\u4f60\u91c7\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u4f60\u5e94\u8be5\u5728\u5f00\u59cb\u5c06\u6570\u7ec4\u4f20\u7ed9\u51fd\u6570\u4e4b\u524d*\u8bc4\u4f30\u5176\u5927\u5c0f\u3002 //\u4f60\u5f00\u59cb\u5c06\u6570\u7ec4\u4f20\u9012\u7ed9\u51fd\u6570\uff08\u89c1\u540e\u9762\u7684\u8ba8\u8bba\uff09\uff0c\u56e0\u4e3a // \u5f53\u6570\u7ec4\u88ab\u4f20\u9012\u7ed9\u51fd\u6570\u65f6\uff0c\u5b83\u4eec\u4f1a\u88ab \"\u964d\u7ea7 \"\u4e3a\u539f\u59cb\u6307\u9488\u3002 // \u6240\u4ee5\u4e0a\u9762\u7684\u8bed\u53e5\u4f1a\u5728\u51fd\u6570\u4e2d\u4ea7\u751f\u9519\u8bef\u7684\u7ed3\u679c\uff09\u3002 // \u7d22\u5f15\u6570\u7ec4\u548c\u5176\u4ed6\u8bed\u8a00\u7c7b\u4f3c -- \u597d\u5427\uff0c\u5176\u5b9e\u662f\u5176\u4ed6\u7684\u8bed\u8a00\u50cfC my_array[0]; // => 0 // \u6570\u7ec4\u662f\u53ef\u53d8\u7684\uff0c\u5176\u5b9e\u5c31\u662f\u5185\u5b58\u7684\u6620\u5c04\uff01 my_array[1] = 2; printf(\"%d\\n\", my_array[1]); // => 2 // \u5728C99 \uff08C11\u4e2d\u662f\u53ef\u9009\u7279\u6027\uff09\uff0c\u53d8\u957f\u6570\u7ec4\uff08VLA\uff09\u4e5f\u53ef\u4ee5\u58f0\u660e\u957f\u5ea6\u3002 // \u5176\u957f\u5ea6\u4e0d\u9700\u8981\u662f\u7f16\u8bd1\u65f6\u5e38\u91cf\u3002 printf(\"Enter the array size: \"); // \u8be2\u95ee\u7528\u6237\u6570\u7ec4\u957f\u5ea6 int array_size; fscanf(stdin, \"%d\", &array_size); int var_length_array[array_size]; // \u58f0\u660e VLA printf(\"sizeof array = %zu\\n\", sizeof var_length_array); // \u4f8b\u5b50\u3002 // > \u8f93\u5165\u6570\u7ec4\u5927\u5c0f\uff1a10 // > sizeof array = 40 // \u5b57\u7b26\u4e32\u53ea\u662f\u4e00\u4e2a\u4ee5NULL\uff080x00\uff09\u5b57\u8282\u4e3a\u7ed3\u5c3e\u7684\u5b57\u7b26\u6570\u7ec4\u3002 // \u5728\u5b57\u7b26\u4e32\u4e2d\u8868\u793a\u4e3a\u7279\u6b8a\u5b57\u7b26'\\0'\u3002 // \uff08\u6211\u4eec\u4e0d\u9700\u8981\u5728\u5b57\u7b26\u4e32\u5b57\u9762\u503c\u4e2d\u5305\u62ec NULL \u5b57\u8282\uff1b // \u7f16\u8bd1\u5668\u4f1a\u628a\u5b83\u63d2\u5165\u5230\u6570\u7ec4\u7684\u672b\u5c3e\uff09\u3002 char a_string[20] = \"This is a string\"; printf(\"%s\\n\", a_string); // %s \u53ef\u4ee5\u5bf9\u5b57\u7b26\u4e32\u8fdb\u884c\u683c\u5f0f\u5316 printf(\"%d\\n\", a_string[16]); // => 0 // \u5373\uff0c17\u53f7\u5b57\u8282\u4e3a0\uff0818\u300119\u548c20\u4e5f\u662f\u5982\u6b64\uff09 // \u5355\u5f15\u53f7\u95f4\u7684\u5b57\u7b26\u662f\u5b57\u7b26\u5b57\u9762\u91cf // \u5b83\u7684\u7c7b\u578b\u662f`int`\uff0c\u800c *\u4e0d\u662f* `char` // \uff08\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff09 int cha = 'a'; // \u5408\u6cd5 char chb = 'a'; // \u540c\u6837\u5408\u6cd5 (\u4ece int \u5230 char \u8fdb\u884c\u4e86\u9690\u5f0f\u7c7b\u578b\u8f6c\u6362) // \u591a\u7ef4\u6570\u7ec4: int multi_array[2][5] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 0} }; // \u8bbf\u95ee\u5143\u7d20: int array_int = multi_array[0][2]; // => 3 /////////////////////////////////////// // \u8fd0\u7b97\u7b26 /////////////////////////////////////// // \u591a\u4e2a\u53d8\u91cf\u58f0\u660e\u7684\u7b80\u5199: int i1 = 1, i2 = 2; float f1 = 1.0, f2 = 2.0; int b, c; b = c = 0; // \u7b97\u6570\u8fd0\u7b97\u76f4\u63a5\u4e86\u5f53 i1 + i2; // => 3 i2 - i1; // => 1 i2 * i1; // => 2 i1 / i2; // => 0 (0.5, \u4f46\u662f\u622a\u65ad\u4e3a 0) // \u4f60\u9700\u8981\u5c06\u81f3\u5c11\u4e00\u4e2a\u6574\u6570\u8f6c\u6362\u6210\u6d6e\u70b9\u6570\uff0c\u624d\u80fd\u5f97\u5230\u4e00\u4e2a\u6d6e\u70b9\u6570\u7684\u7ed3\u679c (float)i1 / i2; // => 0.5f i1 / (double)i2; // => 0.5 // \u53cc\u7cbe\u5ea6\u6d6e\u70b9\u4e5f\u4e00\u6837 f1 / f2; // => 0.5, \u52a0\u4e0a\u6216\u51cf\u53bb epsilon // \u6d6e\u70b9\u6570\u662f\u7531 IEEE 754 \u6807\u51c6\u5b9a\u4e49\u7684, \u56e0\u6b64\u65e0\u6cd5\u5f88\u597d\u7684\u5b58\u50a8 // \u4f8b\u5982\uff0c\u4ee5\u4e0b\u5185\u5bb9\u4e0d\u4f1a\u4ea7\u751f\u9884\u671f\u7684\u7ed3\u679c //\u56e0\u4e3a0.1\u5728\u8ba1\u7b97\u673a\u5185\u90e8\u53ef\u80fd\u5b9e\u9645\u4e0a\u662f0.0999999999\uff0c //\u800c0.3 \u53ef\u80fd\u88ab\u5b58\u50a8\u4e3a0.300000000001\u3002 (0.1 + 0.1 + 0.1) != 0.3; // => 1 (true) // \u5e76\u4e14\u7531\u4e8e\u4e0a\u8ff0\u539f\u56e0\uff0c\u5b83\u662f\u4e0d\u7b26\u5408\u7ed3\u5408\u5f8b\u7684 1 + (1e123 - 1e123) != (1 + 1e123) - 1e123; // => 1 (true) // \u8fd9\u79cd\u8ba1\u6570\u6cd5\u662f\u6570\u5b57\u7684\u79d1\u5b66\u8ba1\u6570\u6cd5: 1e123 = 1*10^123 // \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5927\u591a\u6570\u7cfb\u7edf\u90fd\u4f7f\u7528IEEE 754\u6765\u8868\u793a\u6d6e\u70b9\u3002 // \u6765\u8868\u793a\u6d6e\u70b9\u3002\u5373\u4f7f\u662f\u7528\u4e8e\u79d1\u5b66\u8ba1\u7b97\u7684python\uff0c\u4e5f\u662f\u5982\u6b64\u3002 //\u6700\u7ec8\u4e5f\u4f1a\u8c03\u7528\u4f7f\u7528IEEE 754\u7684C\u8bed\u8a00\u3002\u8fd9\u6837\u8bf4\u5e76\u4e0d\u662f\u4e3a\u4e86 // \u8868\u660e\u8fd9\u662f\u4e2a\u7cdf\u7cd5\u7684\u5b9e\u73b0\uff0c\u800c\u662f\u4f5c\u4e3a\u4e00\u4e2a\u8b66\u544a // \u5f53\u8fdb\u884c\u6d6e\u70b9\u6bd4\u8f83\u65f6\uff0c\u5fc5\u987b\u8981\u8003\u8651\u4e00\u70b9\u8bef\u5dee\uff08epsilon\uff09\u3002 // \u6c42\u4f59\uff08\u53d6\u6a21\uff09\u4e5f\u5728\u90a3\u91cc\uff0c\u4f46\u662f\u5982\u679c\u53c2\u6570\u662f\u8d1f\u7684\uff0c\u8981\u5c0f\u5fc3\u3002 11 % 3; // => 2 as 11 = 2 + 3*x (x=3) (-11) % 3; // => -2, as one would expect 11 % (-3); // => 2 and not -2, and it's quite counter intuitive // \u6bd4\u8f83\u8fd0\u7b97\u7b26\u6216\u8bb8\u6bd4\u8f83\u719f\u6089, \u4f46\u662f // C \u8bed\u8a00\u5f53\u4e2d\u6ca1\u6709\u5e03\u5c14\u7c7b\u578b. \u6211\u4eec\u7528\u6574\u578b\u66ff\u4ee3. // \uff08C99 \u5f15\u5165\u4e86 stdbool.h \u4e2d\u63d0\u4f9b\u7684_Bool\u7c7b\u578b\uff09 // 0 \u4e3a\u5047\uff0c\u5176\u4ed6\u4efb\u4f55\u5185\u5bb9\u90fd\u662f\u771f\u7684. //\u6bd4\u8f83\u8fd0\u7b97\u7b26\u7684\u8fd4\u56de\u503c\u603b\u662f\u4e3a 0 \u6216 1 3 == 2; // => 0 (false) 3 != 2; // => 1 (true) 3 > 2; // => 1 3 < 2; // => 0 2 <= 2; // => 1 2 >= 2; // => 1 // C \u4e0d\u662f Python\uff0c\u8fde\u7eed\u6bd4\u8f83\u4e0d\u5408\u6cd5 // \u8b66\u544a\uff1a \u4e0b\u9762\u8fd9\u4e00\u884c\u53ef\u4ee5\u88ab\u7f16\u8bd1, \u4f46\u662f\u5b83\u8868\u793a\u7684\u662f `(0 < a) < 2`. // \u8be5\u8868\u8fbe\u5f0f\u6c38\u8fdc\u4e3a\u771f, \u56e0\u4e3a (0 < a) \u53ef\u80fd\u662f 1 \u6216 0 \u4e2d\u7684\u4e00\u4e2a // \u5728\u672c\u4f8b\u4e2d\u4e3a 1\uff0c\u56e0\u4e3a 0 \u5c0f\u4e8e 1 int between_0_and_2 = 0 < a < 2; // \u6539\u7528\uff1a int between_0_and_2 = 0 < a && a < 2; // \u903b\u8f91\u8fd0\u7b97\u7b26\u9002\u7528\u4e8e\u6574\u6570 !3; // => 0 (\u903b\u8f91\u975e) !0; // => 1 1 && 1; // => 1 (\u903b\u8f91\u4e0e) 0 && 1; // => 0 0 || 1; // => 1 (\u903b\u8f91\u6216) 0 || 0; // => 0 // \u4e09\u5143\u6761\u4ef6\u8868\u8fbe\u5f0f ( ? : ) int e = 5; int f = 10; int z; z = (e > f) ? e : f; // => 10 \"\u82e5 e > f \u8fd4\u56de e, \u5426\u5219\u8fd4\u56de f.\" // \u589e\u3001\u51cf\u8fd0\u7b97\u7b26: int j = 0; int s = j++; // \u8fd4\u56de j \u7136\u540e\u589e\u52a0 j. (s = 0, j = 1) s = ++j; // \u589e\u52a0 j \u7136\u540e\u8fd4\u56de j. (s = 2, j = 2) // \u5bf9\u4e8e j-- \u548c --j \u4e5f\u4e00\u6837 // \u4f4d\u8fd0\u7b97\u7b26! ~0x0F; // => 0xFFFFFFF0 (\u6309\u4f4d\u53d6\u53cd, \"1 \u7684\u8865\u7801\",32 \u4f4d\u6574\u6570\u7684\u793a\u4f8b\u7ed3\u679c) 0x0F & 0xF0; // => 0x00 (\u6309\u4f4d\u4e0e) 0x0F | 0xF0; // => 0xFF (\u6309\u4f4d\u6216) 0x04 ^ 0x0F; // => 0x0B (\u6309\u4f4d\u5f02\u6216) 0x01 << 1; // => 0x02 (\u6309\u4f4d\u5de6\u79fb\u4e00\u4f4d) 0x02 >> 1; // => 0x01 (\u6309\u4f4d\u53f3\u79fb\u4e00\u4f4d) // \u79fb\u52a8\u6709\u7b26\u53f7\u6574\u6570\u65f6\u8981\u5c0f\u5fc3 - \u4e0b\u9762\u8fd9\u4e9b\u5185\u5bb9\u65f6\u672a\u5b9a\u4e49\u7684: // - shifting into the sign bit of a signed integer (int a = 1 << 31) // - left-shifting a negative number (int a = -1 << 2) // - shifting by an offset which is >= the width of the type of the LHS: // int a = 1 << 32; // UB if int is 32 bits wide /////////////////////////////////////// // \u63a7\u5236\u7ed3\u6784 /////////////////////////////////////// if (0) { printf(\"I am never run\\n\"); } else if (0) { printf(\"I am also never run\\n\"); } else { printf(\"I print\\n\"); } // While \u5faa\u73af\u662f\u5b58\u5728\u7684 int ii = 0; while (ii < 10) { //\u4efb\u4f55\u5c0f\u4e8e 10 \u7684\u503c\u90fd\u4e3a\u771f printf(\"%d, \", ii++); // ii++ \u5728\u4f7f\u7528\u5176\u5f53\u524d\u503c\u540e\u589e\u52a0ii } // => prints \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \" printf(\"\\n\"); int kk = 0; do { printf(\"%d, \", kk); } while (++kk < 10); // ++kk \u5728\u4f7f\u7528\u5176\u5f53\u524d\u503c\u4e4b\u524d\u589e\u52a0ii // => prints \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \" printf(\"\\n\"); // For \u5faa\u73af\u4e5f\u4e00\u6837 int jj; for (jj=0; jj < 10; jj++) { printf(\"%d, \", jj); } // => prints \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \" printf(\"\\n\"); // *****NOTES*****: // \u5faa\u73af\u548c\u51fd\u6570\u5fc5\u987b\u6709\u4e00\u4e2a\u4e3b\u4f53\u3002\u5982\u679c\u4e0d\u9700\u8981\u4e3b\u4f53\u3002 int i; for (i = 0; i <= 5; i++) { ; // \u7528\u5206\u53f7\u4f5c\u4e3a\u4e3b\u4f53\uff08\u7a7a\u8bed\u53e5\uff09\u3002 } // Or for (i = 0; i <= 5; i++); // \u591a\u9009\u62e9\u5206\u652f: switch() switch (a) { case 0: // \u6807\u7b7e\u9700\u8981\u662f\u5b8c\u6574\u7684*\u5e38\u91cf*\u8868\u8fbe\u5f0f\uff08\u5982\u679a\u4e3e\uff09\u3002 printf(\"Hey, 'a' equals 0!\\n\"); break; // if you don't break, control flow falls over labels case 1: printf(\"Huh, 'a' equals 1!\\n\"); break; // Be careful - without a \"break\", execution continues until the // next \"break\" is reached. case 3: case 4: printf(\"Look at that.. 'a' is either 3, or 4\\n\"); break; default: // if `some_integral_expression` didn't match any of the labels fputs(\"Error!\\n\", stderr); exit(-1); break; } /* Using \"goto\" in C */ typedef enum { false, true } bool; // for C don't have bool as data type before C99 :( bool disaster = false; int i, j; for(i=0; i<100; ++i) for(j=0; j<100; ++j) { if((i + j) >= 150) disaster = true; if(disaster) goto error; // exit both for loops } error: // this is a label that you can \"jump\" to with \"goto error;\" printf(\"Error occurred at i = %d & j = %d.\\n\", i, j); /* https://ideone.com/GuPhd6 this will print out \"Error occurred at i = 51 & j = 99.\" */ /* it is generally considered bad practice to do so, except if you really know what you are doing. See https://en.wikipedia.org/wiki/Spaghetti_code#Meaning */ /////////////////////////////////////// // Typecasting /////////////////////////////////////// // Every value in C has a type, but you can cast one value into another type // if you want (with some constraints). int x_hex = 0x01; // You can assign vars with hex literals // binary is not in the standard, but allowed by some // compilers (x_bin = 0b0010010110) // Casting between types will attempt to preserve their numeric values printf(\"%d\\n\", x_hex); // => Prints 1 printf(\"%d\\n\", (short) x_hex); // => Prints 1 printf(\"%d\\n\", (char) x_hex); // => Prints 1 // If you assign a value greater than a types max val, it will rollover // without warning. printf(\"%d\\n\", (unsigned char) 257); // => 1 (Max char = 255 if char is 8 bits long) // For determining the max value of a `char`, a `signed char` and an `unsigned char`, // respectively, use the CHAR_MAX, SCHAR_MAX and UCHAR_MAX macros from <limits.h> // Integral types can be cast to floating-point types, and vice-versa. printf(\"%f\\n\", (double) 100); // %f always formats a double... printf(\"%f\\n\", (float) 100); // ...even with a float. printf(\"%d\\n\", (char)100.0); /////////////////////////////////////// // Pointers /////////////////////////////////////// // A pointer is a variable declared to store a memory address. Its declaration will // also tell you the type of data it points to. You can retrieve the memory address // of your variables, then mess with them. int x = 0; printf(\"%p\\n\", (void *)&x); // Use & to retrieve the address of a variable // (%p formats an object pointer of type void *) // => Prints some address in memory; // Pointers start with * in their declaration int *px, not_a_pointer; // px is a pointer to an int px = &x; // Stores the address of x in px printf(\"%p\\n\", (void *)px); // => Prints some address in memory printf(\"%zu, %zu\\n\", sizeof(px), sizeof(not_a_pointer)); // => Prints \"8, 4\" on a typical 64-bit system // To retrieve the value at the address a pointer is pointing to, // put * in front to dereference it. // Note: yes, it may be confusing that '*' is used for _both_ declaring a // pointer and dereferencing it. printf(\"%d\\n\", *px); // => Prints 0, the value of x // You can also change the value the pointer is pointing to. // We'll have to wrap the dereference in parenthesis because // ++ has a higher precedence than *. (*px)++; // Increment the value px is pointing to by 1 printf(\"%d\\n\", *px); // => Prints 1 printf(\"%d\\n\", x); // => Prints 1 // Arrays are a good way to allocate a contiguous block of memory int x_array[20]; //declares array of size 20 (cannot change size) int xx; for (xx = 0; xx < 20; xx++) { x_array[xx] = 20 - xx; } // Initialize x_array to 20, 19, 18,... 2, 1 // Declare a pointer of type int and initialize it to point to x_array int* x_ptr = x_array; // x_ptr now points to the first element in the array (the integer 20). // This works because arrays often decay into pointers to their first element. // For example, when an array is passed to a function or is assigned to a pointer, // it decays into (implicitly converted to) a pointer. // Exceptions: when the array is the argument of the `&` (address-of) operator: int arr[10]; int (*ptr_to_arr)[10] = &arr; // &arr is NOT of type `int *`! // It's of type \"pointer to array\" (of ten `int`s). // or when the array is a string literal used for initializing a char array: char otherarr[] = \"foobarbazquirk\"; // or when it's the argument of the `sizeof` or `alignof` operator: int arraythethird[10]; int *ptr = arraythethird; // equivalent with int *ptr = &arr[0]; printf(\"%zu, %zu\\n\", sizeof(arraythethird), sizeof(ptr)); // probably prints \"40, 4\" or \"40, 8\" // Pointers are incremented and decremented based on their type // (this is called pointer arithmetic) printf(\"%d\\n\", *(x_ptr + 1)); // => Prints 19 printf(\"%d\\n\", x_array[1]); // => Prints 19 // You can also dynamically allocate contiguous blocks of memory with the // standard library function malloc, which takes one argument of type size_t // representing the number of bytes to allocate (usually from the heap, although this // may not be true on e.g. embedded systems - the C standard says nothing about it). int *my_ptr = malloc(sizeof(*my_ptr) * 20); for (xx = 0; xx < 20; xx++) { *(my_ptr + xx) = 20 - xx; // my_ptr[xx] = 20-xx } // Initialize memory to 20, 19, 18, 17... 2, 1 (as ints) // Be careful passing user-provided values to malloc! If you want // to be safe, you can use calloc instead (which, unlike malloc, also zeros out the memory) int* my_other_ptr = calloc(20, sizeof(int)); // Note that there is no standard way to get the length of a // dynamically allocated array in C. Because of this, if your arrays are // going to be passed around your program a lot, you need another variable // to keep track of the number of elements (size) of an array. See the // functions section for more info. size_t size = 10; int *my_arr = calloc(size, sizeof(int)); // Add an element to the array size++; my_arr = realloc(my_arr, sizeof(int) * size); if (my_arr == NULL) { //Remember to check for realloc failure! return } my_arr[10] = 5; // Dereferencing memory that you haven't allocated gives // \"unpredictable results\" - the program is said to invoke \"undefined behavior\" printf(\"%d\\n\", *(my_ptr + 21)); // => Prints who-knows-what? It may even crash. // When you're done with a malloc'd block of memory, you need to free it, // or else no one else can use it until your program terminates // (this is called a \"memory leak\"): free(my_ptr); // Strings are arrays of char, but they are usually represented as a // pointer-to-char (which is a pointer to the first element of the array). // It's good practice to use `const char *' when referring to a string literal, // since string literals shall not be modified (i.e. \"foo\"[0] = 'a' is ILLEGAL.) const char *my_str = \"This is my very own string literal\"; printf(\"%c\\n\", *my_str); // => 'T' // This is not the case if the string is an array // (potentially initialized with a string literal) // that resides in writable memory, as in: char foo[] = \"foo\"; foo[0] = 'a'; // this is legal, foo now contains \"aoo\" function_1(); } // end main function /////////////////////////////////////// // Functions /////////////////////////////////////// // Function declaration syntax: // <return type> <function name>(<args>) int add_two_ints(int x1, int x2) { return x1 + x2; // Use return to return a value } /* Functions are call by value. When a function is called, the arguments passed to the function are copies of the original arguments (except arrays). Anything you do to the arguments in the function do not change the value of the original argument where the function was called. Use pointers if you need to edit the original argument values. Example: in-place string reversal */ // A void function returns no value void str_reverse(char *str_in) { char tmp; size_t ii = 0; size_t len = strlen(str_in); // `strlen()` is part of the c standard library // NOTE: length returned by `strlen` DOESN'T include the // terminating NULL byte ('\\0') for (ii = 0; ii < len / 2; ii++) { // in C99 you can directly declare type of `ii` here tmp = str_in[ii]; str_in[ii] = str_in[len - ii - 1]; // ii-th char from end str_in[len - ii - 1] = tmp; } } //NOTE: string.h header file needs to be included to use strlen() /* char c[] = \"This is a test.\"; str_reverse(c); printf(\"%s\\n\", c); // => \".tset a si sihT\" */ /* as we can return only one variable to change values of more than one variables we use call by reference */ void swapTwoNumbers(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } /* int first = 10; int second = 20; printf(\"first: %d\\nsecond: %d\\n\", first, second); swapTwoNumbers(&first, &second); printf(\"first: %d\\nsecond: %d\\n\", first, second); // values will be swapped */ // Return multiple values. // C does not allow for returning multiple values with the return statement. If // you would like to return multiple values, then the caller must pass in the // variables where they would like the returned values to go. These variables must // be passed in as pointers such that the function can modify them. int return_multiple( int *array_of_3, int *ret1, int *ret2, int *ret3) { if(array_of_3 == NULL) return 0; //return error code (false) //de-reference the pointer so we modify its value *ret1 = array_of_3[0]; *ret2 = array_of_3[1]; *ret3 = array_of_3[2]; return 1; //return error code (true) } /* With regards to arrays, they will always be passed to functions as pointers. Even if you statically allocate an array like `arr[10]`, it still gets passed as a pointer to the first element in any function calls. Again, there is no standard way to get the size of a dynamically allocated array in C. */ // Size must be passed! // Otherwise, this function has no way of knowing how big the array is. void printIntArray(int *arr, size_t size) { int i; for (i = 0; i < size; i++) { printf(\"arr[%d] is: %d\\n\", i, arr[i]); } } /* int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; int size = 10; printIntArray(my_arr, size); // will print \"arr[0] is: 1\" etc */ // if referring to external variables outside function, you should use the extern keyword. int i = 0; void testFunc() { extern int i; //i here is now using external variable i } // make external variables private to source file with static: static int j = 0; //other files using testFunc2() cannot access variable j void testFunc2() { extern int j; } // The static keyword makes a variable inaccessible to code outside the // compilation unit. (On almost all systems, a \"compilation unit\" is a .c // file.) static can apply both to global (to the compilation unit) variables, // functions, and function-local variables. When using static with // function-local variables, the variable is effectively global and retains its // value across function calls, but is only accessible within the function it // is declared in. Additionally, static variables are initialized to 0 if not // declared with some other starting value. //**You may also declare functions as static to make them private** /////////////////////////////////////// // User-defined types and structs /////////////////////////////////////// // Typedefs can be used to create type aliases typedef int my_type; my_type my_type_var = 0; // Structs are just collections of data, the members are allocated sequentially, // in the order they are written: struct rectangle { int width; int height; }; // It's not generally true that // sizeof(struct rectangle) == sizeof(int) + sizeof(int) // due to potential padding between the structure members (this is for alignment // reasons). [1] void function_1() { struct rectangle my_rec; // Access struct members with . my_rec.width = 10; my_rec.height = 20; // You can declare pointers to structs struct rectangle *my_rec_ptr = &my_rec; // Use dereferencing to set struct pointer members... (*my_rec_ptr).width = 30; // ... or even better: prefer the -> shorthand for the sake of readability my_rec_ptr->height = 10; // Same as (*my_rec_ptr).height = 10; } // You can apply a typedef to a struct for convenience typedef struct rectangle rect; int area(rect r) { return r.width * r.height; } // if you have large structs, you can pass them \"by pointer\" to avoid copying // the whole struct: int areaptr(const rect *r) { return r->width * r->height; } /////////////////////////////////////// // Function pointers /////////////////////////////////////// /* At run time, functions are located at known memory addresses. Function pointers are much like any other pointer (they just store a memory address), but can be used to invoke functions directly, and to pass handlers (or callback functions) around. However, definition syntax may be initially confusing. Example: use str_reverse from a pointer */ void str_reverse_through_pointer(char *str_in) { // Define a function pointer variable, named f. void (*f)(char *); // Signature should exactly match the target function. f = &str_reverse; // Assign the address for the actual function (determined at run time) // f = str_reverse; would work as well - functions decay into pointers, similar to arrays (*f)(str_in); // Just calling the function through the pointer // f(str_in); // That's an alternative but equally valid syntax for calling it. } /* As long as function signatures match, you can assign any function to the same pointer. Function pointers are usually typedef'd for simplicity and readability, as follows: */ typedef void (*my_fnp_type)(char *); // Then used when declaring the actual pointer variable: // ... // my_fnp_type f; ///////////////////////////// // Printing characters with printf() ///////////////////////////// //Special characters: /* '\\a'; // alert (bell) character '\\n'; // newline character '\\t'; // tab character (left justifies text) '\\v'; // vertical tab '\\f'; // new page (form feed) '\\r'; // carriage return '\\b'; // backspace character '\\0'; // NULL character. Usually put at end of strings in C. // hello\\n\\0. \\0 used by convention to mark end of string. '\\\\'; // backslash '\\?'; // question mark '\\''; // single quote '\\\"'; // double quote '\\xhh'; // hexadecimal number. Example: '\\xb' = vertical tab character '\\0oo'; // octal number. Example: '\\013' = vertical tab character //print formatting: \"%d\"; // integer \"%3d\"; // integer with minimum of length 3 digits (right justifies text) \"%s\"; // string \"%f\"; // float \"%ld\"; // long \"%3.2f\"; // minimum 3 digits left and 2 digits right decimal float \"%7.4s\"; // (can do with strings too) \"%c\"; // char \"%p\"; // pointer. NOTE: need to (void *)-cast the pointer, before passing // it as an argument to `printf`. \"%x\"; // hexadecimal \"%o\"; // octal \"%%\"; // prints % */ /////////////////////////////////////// // Order of Evaluation /////////////////////////////////////// // From top to bottom, top has higher precedence //---------------------------------------------------// // Operators | Associativity // //---------------------------------------------------// // () [] -> . | left to right // // ! ~ ++ -- + = *(type) sizeof | right to left // // * / % | left to right // // + - | left to right // // << >> | left to right // // < <= > >= | left to right // // == != | left to right // // & | left to right // // ^ | left to right // // | | left to right // // && | left to right // // || | left to right // // ?: | right to left // // = += -= *= /= %= &= ^= |= <<= >>= | right to left // // , | left to right // //---------------------------------------------------// /******************************* Header Files ********************************** Header files are an important part of C as they allow for the connection of C source files and can simplify code and definitions by separating them into separate files. Header files are syntactically similar to C source files but reside in \".h\" files. They can be included in your C source file by using the precompiler command #include \"example.h\", given that example.h exists in the same directory as the C file. */ /* A safe guard to prevent the header from being defined too many times. This */ /* happens in the case of circle dependency, the contents of the header is */ /* already defined. */ #ifndef EXAMPLE_H /* if EXAMPLE_H is not yet defined. */ #define EXAMPLE_H /* Define the macro EXAMPLE_H. */ /* Other headers can be included in headers and therefore transitively */ /* included into files that include this header. */ #include <string.h> /* Like for c source files, macros can be defined in headers */ /* and used in files that include this header file. */ #define EXAMPLE_NAME \"Dennis Ritchie\" /* Function macros can also be defined. */ #define ADD(a, b) ((a) + (b)) /* Notice the parenthesis surrounding the arguments -- this is important to */ /* ensure that a and b don't get expanded in an unexpected way (e.g. consider */ /* MUL(x, y) (x * y); MUL(1 + 2, 3) would expand to (1 + 2 * 3), yielding an */ /* incorrect result) */ /* Structs and typedefs can be used for consistency between files. */ typedef struct Node { int val; struct Node *next; } Node; /* So can enumerations. */ enum traffic_light_state {GREEN, YELLOW, RED}; /* Function prototypes can also be defined here for use in multiple files, */ /* but it is bad practice to define the function in the header. Definitions */ /* should instead be put in a C file. */ Node createLinkedList(int *vals, int len); /* Beyond the above elements, other definitions should be left to a C source */ /* file. Excessive includes or definitions should, also not be contained in */ /* a header file but instead put into separate headers or a C file. */ #endif /* End of the if precompiler directive. */","title":"C"},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/#c","text":"\u6765\u6e90 Learn X in Y minutes // \u5355\u884c\u6ce8\u91ca\u4ee5 // \u5f00\u59cb\uff0c\u4ec5\u9002\u7528\u4e8eC99\u53ca\u4ee5\u540e\u3002 /* \u591a\u884c\u6ce8\u91ca\u770b\u8d77\u6765\u50cf\u8fd9\u6837\uff0c\u5bf9\u4e8e C89 \u4e5f\u9002\u7528 */ /* \u591a\u884c\u6ce8\u91ca\u4e0d\u80fd\u88ab\u5d4c\u5957 /* \u52a1\u5fc5\u5c0f\u5fc3 */ // \u8fd9\u6761\u6ce8\u91ca\u5728\u8fd9\u4e00\u884c\u5c31\u7ec8\u6b62\u4e86 */ // \u800c\u4e0d\u662f\u8fd9\u4e00\u884c\uff01 // \u5e38\u91cf\uff1a #define <\u5173\u952e\u5b57> // \u5e38\u91cf\u5b8c\u5168\u5199\u6210\u5927\u5199\u5b57\u6bcd\u662f\u60ef\u4f8b\uff0c\u4e0d\u662f\u5fc5\u987b\u7684\u8981\u6c42 #define DAYS_IN_YEAR 365 // \u679a\u4e3e\u5e38\u91cf\u4e5f\u662f\u58f0\u660e\u5e38\u91cf\u7684\u65b9\u6cd5\u3002 // \u6240\u6709\u7684\u8bed\u53e5\u5fc5\u987b\u4ee5\u5206\u53f7\u7ed3\u675f\u3002 enum days {SUN, MON, TUE, WED, THU, FRI, SAT}; // SUN \u88ab\u8d4b\u503c\u4e3a 0, MON \u88ab\u8d4b\u503c\u4e3a 1, TUE \u88ab\u8d4b\u503c\u4e3a 2, \u4ee5\u6b64\u7c7b\u63a8. // \u679a\u4e3e\u7684\u503c\u662f\u53ef\u4ee5\u88ab\u6307\u5b9a\u7684 enum days {SUN = 1, MON, TUE, WED = 99, THU, FRI, SAT}; // MON \u88ab\u81ea\u52a8\u8d4b\u503c\u4e3a 2, TUE \u88ab\u8d4b\u503c\u4e3a 3, \u4ee5\u6b64\u7c7b\u63a8. // WED \u88ab\u8d4b\u503c\u4e3a 99, THU \u88ab\u8d4b\u503c\u4e3a 100, FRI \u88ab\u8d4b\u503c\u4e3a 101, \u4ee5\u6b64\u7c7b\u63a8. // \u4f7f\u7528 #include \u5bfc\u5165\u5934\u6587\u4ef6 #include <stdlib.h> #include <stdio.h> #include <string.h> // \u5728<\u5c16\u62ec\u53f7>\u4e4b\u95f4\u7684\u6587\u4ef6\u540d\u544a\u8bc9\u7f16\u8bd1\u5668\u8981\u5728\u4f60\u7684\u7cfb\u7edf\u4e2d\u5bfb\u627e // \u5e93\u6216\u8005\u5934\u6587\u4ef6 // \u5bf9\u4e8e\u4f60\u81ea\u5df1\u7684\u5934\u6587\u4ef6\uff0c\u5e94\u8be5\u4f7f\u7528\u53cc\u5f15\u53f7\u800c\u4e0d\u662f\u5c16\u62ec\u53f7\uff0c\u4e14 // \u5e94\u8be5\u63d0\u4f9b\u8def\u5f84 #include \"my_header.h\" // \u672c\u5730\u6587\u4ef6 #include \"../my_lib/my_lib_header.h\" //\u76f8\u5bf9\u8def\u5f84 // \u5728 .h \u6587\u4ef6\u4e2d\u63d0\u524d\u58f0\u660e\u51fd\u6570\u7b7e\u540di\u6216\u8005 // \u5728\u4f60 .c \u6587\u4ef6\u7684\u4e0a\u65b9 void function_1(); int function_2(void); // \u81f3\u5c11\uff0c\u4f60\u5fc5\u987b\u5728\u4efb\u4f55\u51fd\u6570\u4e2d\u4f7f\u7528 \"\u51fd\u6570\u539f\u578b \"\u4e4b\u524d\u58f0\u660e\u5b83\u3002 // \u901a\u5e38\u60c5\u51b5\u4e0b\uff0c\u539f\u578b\u88ab\u653e\u7f6e\u5728\u6587\u4ef6\u7684\u9876\u90e8\uff0c\u5728\u4efb\u4f55\u51fd\u6570\u5b9a\u4e49\u4e4b\u524d\u3002 int add_two_ints(int x1, int x2); // function prototype // \u5c3d\u7ba1`int add_two_ints(int, int);`\u4e5f\u662f\u6709\u6548\u7684\uff08\u4e0d\u9700\u8981\u7ed9\u53c2\u6570\u547d\u540d\uff09\u3002 // \u5efa\u8bae\u5728\u539f\u578b\u4e2d\u4e5f\u4e3a\u53c2\u6570\u547d\u540d\uff0c\u4ece\u800c\u65b9\u4fbf\u68c0\u67e5\u3002 // \u5982\u679c\u51fd\u6570\u5b9a\u4e49\u5728\u8c03\u7528\u8be5\u51fd\u6570\u7684\u4efb\u4f55\u5176\u4ed6\u51fd\u6570\u4e4b\u524d // \u90a3\u4e48\u51fd\u6570\u539f\u578b\u5c31\u4e0d\u662f\u5fc5\u987b\u7684\u3002\u7136\u800c\uff0c\u6807\u51c6\u7684\u505a\u6cd5\u662f // \u59cb\u7ec8\u5c06\u51fd\u6570\u539f\u578b\u6dfb\u52a0\u5230\u5934\u6587\u4ef6(*.h)\u4e2d\uff0c\u7136\u540e\u5728\u5934\u6587\u4ef6\u4e2d#include\u8be5\u6587\u4ef6\u3002 // \u8fd9\u53ef\u4ee5\u9632\u6b62\u5728\u7f16\u8bd1\u5668\u77e5\u9053\u4e00\u4e2a\u51fd\u6570\u7684\u540d\u5b57\u4e4b\u524d\uff0c\u8be5\u51fd\u6570\u5c31\u88ab\u8c03\u7528\u7684\u95ee\u9898\u3002 // \u9664\u6b64\u4e4b\u5916\uff0c\u5b83\u4e3a\u5f00\u53d1\u8005\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5e72\u51c0\u7684\u5934\u6587\u4ef6 // \u4ece\u800c\u53ef\u4ee5\u548c\u9879\u76ee\u7684\u5176\u4ed6\u90e8\u5206\u5171\u4eab // \u4f60\u7684\u7a0b\u5e8f\u7684\u5165\u53e3\u662f\u4e00\u4e2a main \u51fd\u6570\uff0c\u5b83\u7684\u8fd4\u56de\u7c7b\u578b\u53ef\u4ee5\u4e3a\u4efb\u610f\u7c7b\u578b // \u7136\u800c\uff0c\u591a\u6570\u64cd\u4f5c\u7cfb\u7edf\u5e0c\u671b\u5b83\u7684\u8fd4\u56de\u503c\u4e3a int \u7c7b\u578b\uff0c\u4ece\u800c // \u7528\u4e8e\u5904\u7406\u9519\u8bef\u4ee3\u7801 int main(void) { // your program } // \u7528\u4e8e\u8fd0\u884c\u4f60\u7684\u7a0b\u5e8f\u7684\u547d\u4ee4\u884c\u53c2\u6570\u4e5f\u88ab\u4f20\u9012\u7ed9 main // argc\u662f\u53c2\u6570\u7684\u6570\u91cf--\u4f60\u7684\u7a0b\u5e8f\u540d\u79f0\u7b97\u4f5c 1 // argv\u662f\u4e00\u4e2a\u5b57\u7b26\u6570\u7ec4--\u5305\u542b\u53c2\u6570\u672c\u8eab // argv[0] = \u4f60\u7684\u7a0b\u5e8f\u540d\u79f0\uff0cargv[1] = \u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u4ee5\u6b64\u7c7b\u63a8 int main (int argc, char** argv) { // \u6253\u5370\u8f93\u51fa\u4f7f\u7528 printf \u610f\u601d\u662f\"\u683c\u5f0f\u5316\u6253\u5370\" // %d \u4ee3\u8868\u6574\u6570, \\n \u4ee3\u8868\u6362\u884c printf(\"%d\\n\", 0); // => \u6253\u5370 0 /////////////////////////////////////// // \u7c7b\u578b /////////////////////////////////////// // \u4e0d\u7b26\u5408 C99 \u6807\u51c6\u7684\u7f16\u8bd1\u5668\u8981\u6c42\u53d8\u91cf\u5fc5\u987b\u5728\u5f53\u524d\u5757\u8303\u56f4\u7684\u9876\u90e8\u58f0\u660e // \u7b26\u5408 C99 \u6807\u51c6\u7684\u7f16\u8bd1\u5668\u5141\u8bb8\u5728\u4f7f\u7528\u6570\u503c\u7684\u5730\u65b9\u8fdb\u884c\u58f0\u660e // \u5728\u672c\u6559\u7a0b\u4e2d\uff0c\u53d8\u91cf\u5728\u7b26\u5408 C99 \u6807\u51c6\u7684\u60c5\u51b5\u4e0b\u662f\u52a8\u6001\u58f0\u660e\u7684\u3002 // int\u578b\uff08\u6574\u578b\uff09\u53d8\u91cf\u4e00\u822c\u5360\u7528 4 \u4e2a\u5b57\u8282 (\u4f7f\u7528`sizeof`\u8fd0\u7b97\u7b26\u53ef\u4ee5\u68c0\u67e5) int x_int = 0; // short\u578b\uff08\u77ed\u6574\u578b\uff09\u53d8\u91cf\u4e00\u822c\u5360\u7528 2 \u4e2a\u5b57\u8282 (\u4f7f\u7528`sizeof`\u8fd0\u7b97\u7b26\u53ef\u4ee5\u68c0\u67e5) short x_short = 0; // \u5b57\u7b26\u7c7b\u578b\u88ab\u5b9a\u4e49\u4e3a\u4e00\u4e2a\u5904\u7406\u5668\u7684\u6700\u5c0f\u53ef\u5bfb\u5740\u5355\u4f4d\u3002 // \u901a\u5e38\u662f 1 \u4e2a\u5b57\u8282, \u4f46\u5728\u67d0\u4e9b\u7cfb\u7edf\u4e2d\u5b83\u53ef\u4ee5\u66f4\u591a (\u4f8b\u5982\uff0c\u5728\u5fb7\u5dde\u4eea\u5668\u7684 TMS320 \u4e2d\u5b83\u662f 2 \u4e2a\u5b57\u8282). char x_char = 0; char y_char = 'y'; // \u5b57\u7b26\u53d8\u91cf\u7684\u5b57\u9762\u503c\u9700\u8981\u7528\u5355\u5f15\u53f7\u5305\u4f4f // long\u578b\uff08\u957f\u6574\u578b\uff09\u4e00\u822c\u9700\u8981 4 \u4e2a\u5b57\u8282\u5230 8 \u4e2a\u5b57\u8282; \u800clong long\u578b\u5219\u81f3\u5c11\u9700\u8981\u4fdd\u8bc1\u6709 8 \u4e2a\u5b57\u8282\uff0864 \u4f4d\uff09 long x_long = 0; long long x_long_long = 0; // float\u4e00\u822c\u662f\u7528 32 \u4f4d\u8868\u793a\u7684\u6d6e\u70b9\u6570\u5b57 float x_float = 0.0f; // 'f' suffix here denotes floating point literal // double\u4e00\u822c\u662f\u7528 64 \u4f4d\u8868\u793a\u7684\u6d6e\u70b9\u6570\u5b57 double x_double = 0.0; // real numbers without any suffix are doubles // \u6574\u6570\u7c7b\u578b\u4e5f\u53ef\u4ee5\u6709\u65e0\u7b26\u53f7\u7684\u7c7b\u578b\u8868\u793a\u3002\u8fd9\u6837\u8fd9\u4e9b\u53d8\u91cf\u5c31\u65e0\u6cd5\u8868\u793a\u8d1f\u6570 // \u4f46\u662f\u65e0\u7b26\u53f7\u6574\u6570\u6240\u80fd\u8868\u793a\u7684\u8303\u56f4\u5c31\u53ef\u4ee5\u6bd4\u539f\u6765\u7684\u6574\u6570\u5927\u4e00\u4e9b unsigned short ux_short; unsigned int ux_int; unsigned long long ux_long_long; // \u5355\u5f15\u53f7\u5185\u7684\u5b57\u7b26\u662f\u673a\u5668\u7684\u5b57\u7b26\u96c6\u4e2d\u7684\u6574\u6570\u3002 '0' // => \u5728 ASCII \u5b57\u7b26\u96c6\u4e2d\u662f 48 'A' // => \u5728 ASCII \u5b57\u7b26\u96c6\u4e2d\u662f 65 // sizeof(T) \u7ed9\u51fa\u4e86\u7c7b\u578b\u4e3aT\u7684\u53d8\u91cf\u7684\u5927\u5c0f\uff0c\u5355\u4f4d\u4e3a\u5b57\u8282\u3002 // sizeof(obj) \u4ea7\u751f\u8868\u8fbe\u5f0f\uff08\u53d8\u91cf\u3001\u5b57\u9762\u610f\u4e49\u7b49\uff09\u7684\u5927\u5c0f\u3002 printf(\"%zu\\n\", sizeof(int)); // => 4 (\u5728\u591a\u6570 4 \u5b57\u8282\u5b57\u957f\u7684\u673a\u5668\u4e0a) // \u5982\u679c`sizeof`\u7684\u53c2\u6570\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f\uff0c\u90a3\u4e48\u8fd9\u4e2a\u53c2\u6570\u4e0d\u4f1a\u88ab\u6f14\u7b97\uff08VLA\u4f8b\u5916\uff0c\u89c1\u4e0b\uff09 // \u5b83\u4ea7\u751f\u7684\u503c\u662f\u7f16\u8bd1\u65f6\u7684\u5e38\u91cf int a = 1; // size_t\u662f\u4e00\u4e2a\u65e0\u7b26\u53f7\u6574\u578b\uff0c\u8868\u793a\u5bf9\u8c61\u7684\u5c3a\u5bf8\uff0c\u81f3\u5c11 2 \u4e2a\u5b57\u8282 size_t size = sizeof(a++); // a++ \u4e0d\u4f1a\u88ab\u6f14\u7b97 printf(\"sizeof(a++) = %zu where a = %d\\n\", size, a); // \u6253\u5370 \"sizeof(a++) = 4 where a = 1\" \uff08\u572832\u4f4d\u67b6\u6784\u4e0a\uff09 // \u6570\u7ec4\u5fc5\u987b\u88ab\u521d\u59cb\u5316\u4e3a\u5177\u4f53\u7684\u957f\u5ea6 char my_char_array[20]; // \u8fd9\u4e2a\u6570\u7ec4\u5360\u636e 1 * 20 = 20 \u5b57\u8282 int my_int_array[20]; // \u8fd9\u4e2a\u6570\u7ec4\u5360\u636e 4 * 20 = 80 \u5b57\u8282 // (\u5047\u8bbe\u4e3a 4 \u5b57\u8282\u5b57\u957f) // \u4f60\u53ef\u4ee5\u5c06\u4e00\u4e2a\u6570\u7ec4\u521d\u59cb\u5316\u4e3a\u96f6: char my_array[20] = {0}; // \u5176\u4e2d\"{0}\"\u90e8\u5206\u88ab\u79f0\u4e3a \"\u6570\u7ec4\u521d\u59cb\u5316\u5668\"\u3002 // \u6ce8\u610f\uff0c\u5982\u679c\u4f60\u5728\u540c\u4e00\u884c\u4e2d\u521d\u59cb\u5316\u6570\u7ec4 // \u4f60\u5c31\u53ef\u4ee5\u4e0d\u660e\u786e\u5730\u58f0\u660e\u6570\u7ec4\u7684\u5927\u5c0f\u3002 // \u6240\u4ee5\uff0c\u4e0b\u9762\u7684\u58f0\u660e\u4e5f\u662f\u5408\u6cd5\u7684\u3002 char my_array[] = {0}; // \u4f46\u662f\uff0c\u7136\u540e\u4f60\u5fc5\u987b\u5728\u8fd0\u884c\u65f6\u8bc4\u4f30\u6570\u7ec4\u7684\u5927\u5c0f\uff0c\u50cf\u8fd9\u6837: size_t my_array_size = sizeof(my_array) / sizeof(my_array[0]); // \u8b66\u544a \u5982\u679c\u4f60\u91c7\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u4f60\u5e94\u8be5\u5728\u5f00\u59cb\u5c06\u6570\u7ec4\u4f20\u7ed9\u51fd\u6570\u4e4b\u524d*\u8bc4\u4f30\u5176\u5927\u5c0f\u3002 //\u4f60\u5f00\u59cb\u5c06\u6570\u7ec4\u4f20\u9012\u7ed9\u51fd\u6570\uff08\u89c1\u540e\u9762\u7684\u8ba8\u8bba\uff09\uff0c\u56e0\u4e3a // \u5f53\u6570\u7ec4\u88ab\u4f20\u9012\u7ed9\u51fd\u6570\u65f6\uff0c\u5b83\u4eec\u4f1a\u88ab \"\u964d\u7ea7 \"\u4e3a\u539f\u59cb\u6307\u9488\u3002 // \u6240\u4ee5\u4e0a\u9762\u7684\u8bed\u53e5\u4f1a\u5728\u51fd\u6570\u4e2d\u4ea7\u751f\u9519\u8bef\u7684\u7ed3\u679c\uff09\u3002 // \u7d22\u5f15\u6570\u7ec4\u548c\u5176\u4ed6\u8bed\u8a00\u7c7b\u4f3c -- \u597d\u5427\uff0c\u5176\u5b9e\u662f\u5176\u4ed6\u7684\u8bed\u8a00\u50cfC my_array[0]; // => 0 // \u6570\u7ec4\u662f\u53ef\u53d8\u7684\uff0c\u5176\u5b9e\u5c31\u662f\u5185\u5b58\u7684\u6620\u5c04\uff01 my_array[1] = 2; printf(\"%d\\n\", my_array[1]); // => 2 // \u5728C99 \uff08C11\u4e2d\u662f\u53ef\u9009\u7279\u6027\uff09\uff0c\u53d8\u957f\u6570\u7ec4\uff08VLA\uff09\u4e5f\u53ef\u4ee5\u58f0\u660e\u957f\u5ea6\u3002 // \u5176\u957f\u5ea6\u4e0d\u9700\u8981\u662f\u7f16\u8bd1\u65f6\u5e38\u91cf\u3002 printf(\"Enter the array size: \"); // \u8be2\u95ee\u7528\u6237\u6570\u7ec4\u957f\u5ea6 int array_size; fscanf(stdin, \"%d\", &array_size); int var_length_array[array_size]; // \u58f0\u660e VLA printf(\"sizeof array = %zu\\n\", sizeof var_length_array); // \u4f8b\u5b50\u3002 // > \u8f93\u5165\u6570\u7ec4\u5927\u5c0f\uff1a10 // > sizeof array = 40 // \u5b57\u7b26\u4e32\u53ea\u662f\u4e00\u4e2a\u4ee5NULL\uff080x00\uff09\u5b57\u8282\u4e3a\u7ed3\u5c3e\u7684\u5b57\u7b26\u6570\u7ec4\u3002 // \u5728\u5b57\u7b26\u4e32\u4e2d\u8868\u793a\u4e3a\u7279\u6b8a\u5b57\u7b26'\\0'\u3002 // \uff08\u6211\u4eec\u4e0d\u9700\u8981\u5728\u5b57\u7b26\u4e32\u5b57\u9762\u503c\u4e2d\u5305\u62ec NULL \u5b57\u8282\uff1b // \u7f16\u8bd1\u5668\u4f1a\u628a\u5b83\u63d2\u5165\u5230\u6570\u7ec4\u7684\u672b\u5c3e\uff09\u3002 char a_string[20] = \"This is a string\"; printf(\"%s\\n\", a_string); // %s \u53ef\u4ee5\u5bf9\u5b57\u7b26\u4e32\u8fdb\u884c\u683c\u5f0f\u5316 printf(\"%d\\n\", a_string[16]); // => 0 // \u5373\uff0c17\u53f7\u5b57\u8282\u4e3a0\uff0818\u300119\u548c20\u4e5f\u662f\u5982\u6b64\uff09 // \u5355\u5f15\u53f7\u95f4\u7684\u5b57\u7b26\u662f\u5b57\u7b26\u5b57\u9762\u91cf // \u5b83\u7684\u7c7b\u578b\u662f`int`\uff0c\u800c *\u4e0d\u662f* `char` // \uff08\u7531\u4e8e\u5386\u53f2\u539f\u56e0\uff09 int cha = 'a'; // \u5408\u6cd5 char chb = 'a'; // \u540c\u6837\u5408\u6cd5 (\u4ece int \u5230 char \u8fdb\u884c\u4e86\u9690\u5f0f\u7c7b\u578b\u8f6c\u6362) // \u591a\u7ef4\u6570\u7ec4: int multi_array[2][5] = { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 0} }; // \u8bbf\u95ee\u5143\u7d20: int array_int = multi_array[0][2]; // => 3 /////////////////////////////////////// // \u8fd0\u7b97\u7b26 /////////////////////////////////////// // \u591a\u4e2a\u53d8\u91cf\u58f0\u660e\u7684\u7b80\u5199: int i1 = 1, i2 = 2; float f1 = 1.0, f2 = 2.0; int b, c; b = c = 0; // \u7b97\u6570\u8fd0\u7b97\u76f4\u63a5\u4e86\u5f53 i1 + i2; // => 3 i2 - i1; // => 1 i2 * i1; // => 2 i1 / i2; // => 0 (0.5, \u4f46\u662f\u622a\u65ad\u4e3a 0) // \u4f60\u9700\u8981\u5c06\u81f3\u5c11\u4e00\u4e2a\u6574\u6570\u8f6c\u6362\u6210\u6d6e\u70b9\u6570\uff0c\u624d\u80fd\u5f97\u5230\u4e00\u4e2a\u6d6e\u70b9\u6570\u7684\u7ed3\u679c (float)i1 / i2; // => 0.5f i1 / (double)i2; // => 0.5 // \u53cc\u7cbe\u5ea6\u6d6e\u70b9\u4e5f\u4e00\u6837 f1 / f2; // => 0.5, \u52a0\u4e0a\u6216\u51cf\u53bb epsilon // \u6d6e\u70b9\u6570\u662f\u7531 IEEE 754 \u6807\u51c6\u5b9a\u4e49\u7684, \u56e0\u6b64\u65e0\u6cd5\u5f88\u597d\u7684\u5b58\u50a8 // \u4f8b\u5982\uff0c\u4ee5\u4e0b\u5185\u5bb9\u4e0d\u4f1a\u4ea7\u751f\u9884\u671f\u7684\u7ed3\u679c //\u56e0\u4e3a0.1\u5728\u8ba1\u7b97\u673a\u5185\u90e8\u53ef\u80fd\u5b9e\u9645\u4e0a\u662f0.0999999999\uff0c //\u800c0.3 \u53ef\u80fd\u88ab\u5b58\u50a8\u4e3a0.300000000001\u3002 (0.1 + 0.1 + 0.1) != 0.3; // => 1 (true) // \u5e76\u4e14\u7531\u4e8e\u4e0a\u8ff0\u539f\u56e0\uff0c\u5b83\u662f\u4e0d\u7b26\u5408\u7ed3\u5408\u5f8b\u7684 1 + (1e123 - 1e123) != (1 + 1e123) - 1e123; // => 1 (true) // \u8fd9\u79cd\u8ba1\u6570\u6cd5\u662f\u6570\u5b57\u7684\u79d1\u5b66\u8ba1\u6570\u6cd5: 1e123 = 1*10^123 // \u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5927\u591a\u6570\u7cfb\u7edf\u90fd\u4f7f\u7528IEEE 754\u6765\u8868\u793a\u6d6e\u70b9\u3002 // \u6765\u8868\u793a\u6d6e\u70b9\u3002\u5373\u4f7f\u662f\u7528\u4e8e\u79d1\u5b66\u8ba1\u7b97\u7684python\uff0c\u4e5f\u662f\u5982\u6b64\u3002 //\u6700\u7ec8\u4e5f\u4f1a\u8c03\u7528\u4f7f\u7528IEEE 754\u7684C\u8bed\u8a00\u3002\u8fd9\u6837\u8bf4\u5e76\u4e0d\u662f\u4e3a\u4e86 // \u8868\u660e\u8fd9\u662f\u4e2a\u7cdf\u7cd5\u7684\u5b9e\u73b0\uff0c\u800c\u662f\u4f5c\u4e3a\u4e00\u4e2a\u8b66\u544a // \u5f53\u8fdb\u884c\u6d6e\u70b9\u6bd4\u8f83\u65f6\uff0c\u5fc5\u987b\u8981\u8003\u8651\u4e00\u70b9\u8bef\u5dee\uff08epsilon\uff09\u3002 // \u6c42\u4f59\uff08\u53d6\u6a21\uff09\u4e5f\u5728\u90a3\u91cc\uff0c\u4f46\u662f\u5982\u679c\u53c2\u6570\u662f\u8d1f\u7684\uff0c\u8981\u5c0f\u5fc3\u3002 11 % 3; // => 2 as 11 = 2 + 3*x (x=3) (-11) % 3; // => -2, as one would expect 11 % (-3); // => 2 and not -2, and it's quite counter intuitive // \u6bd4\u8f83\u8fd0\u7b97\u7b26\u6216\u8bb8\u6bd4\u8f83\u719f\u6089, \u4f46\u662f // C \u8bed\u8a00\u5f53\u4e2d\u6ca1\u6709\u5e03\u5c14\u7c7b\u578b. \u6211\u4eec\u7528\u6574\u578b\u66ff\u4ee3. // \uff08C99 \u5f15\u5165\u4e86 stdbool.h \u4e2d\u63d0\u4f9b\u7684_Bool\u7c7b\u578b\uff09 // 0 \u4e3a\u5047\uff0c\u5176\u4ed6\u4efb\u4f55\u5185\u5bb9\u90fd\u662f\u771f\u7684. //\u6bd4\u8f83\u8fd0\u7b97\u7b26\u7684\u8fd4\u56de\u503c\u603b\u662f\u4e3a 0 \u6216 1 3 == 2; // => 0 (false) 3 != 2; // => 1 (true) 3 > 2; // => 1 3 < 2; // => 0 2 <= 2; // => 1 2 >= 2; // => 1 // C \u4e0d\u662f Python\uff0c\u8fde\u7eed\u6bd4\u8f83\u4e0d\u5408\u6cd5 // \u8b66\u544a\uff1a \u4e0b\u9762\u8fd9\u4e00\u884c\u53ef\u4ee5\u88ab\u7f16\u8bd1, \u4f46\u662f\u5b83\u8868\u793a\u7684\u662f `(0 < a) < 2`. // \u8be5\u8868\u8fbe\u5f0f\u6c38\u8fdc\u4e3a\u771f, \u56e0\u4e3a (0 < a) \u53ef\u80fd\u662f 1 \u6216 0 \u4e2d\u7684\u4e00\u4e2a // \u5728\u672c\u4f8b\u4e2d\u4e3a 1\uff0c\u56e0\u4e3a 0 \u5c0f\u4e8e 1 int between_0_and_2 = 0 < a < 2; // \u6539\u7528\uff1a int between_0_and_2 = 0 < a && a < 2; // \u903b\u8f91\u8fd0\u7b97\u7b26\u9002\u7528\u4e8e\u6574\u6570 !3; // => 0 (\u903b\u8f91\u975e) !0; // => 1 1 && 1; // => 1 (\u903b\u8f91\u4e0e) 0 && 1; // => 0 0 || 1; // => 1 (\u903b\u8f91\u6216) 0 || 0; // => 0 // \u4e09\u5143\u6761\u4ef6\u8868\u8fbe\u5f0f ( ? : ) int e = 5; int f = 10; int z; z = (e > f) ? e : f; // => 10 \"\u82e5 e > f \u8fd4\u56de e, \u5426\u5219\u8fd4\u56de f.\" // \u589e\u3001\u51cf\u8fd0\u7b97\u7b26: int j = 0; int s = j++; // \u8fd4\u56de j \u7136\u540e\u589e\u52a0 j. (s = 0, j = 1) s = ++j; // \u589e\u52a0 j \u7136\u540e\u8fd4\u56de j. (s = 2, j = 2) // \u5bf9\u4e8e j-- \u548c --j \u4e5f\u4e00\u6837 // \u4f4d\u8fd0\u7b97\u7b26! ~0x0F; // => 0xFFFFFFF0 (\u6309\u4f4d\u53d6\u53cd, \"1 \u7684\u8865\u7801\",32 \u4f4d\u6574\u6570\u7684\u793a\u4f8b\u7ed3\u679c) 0x0F & 0xF0; // => 0x00 (\u6309\u4f4d\u4e0e) 0x0F | 0xF0; // => 0xFF (\u6309\u4f4d\u6216) 0x04 ^ 0x0F; // => 0x0B (\u6309\u4f4d\u5f02\u6216) 0x01 << 1; // => 0x02 (\u6309\u4f4d\u5de6\u79fb\u4e00\u4f4d) 0x02 >> 1; // => 0x01 (\u6309\u4f4d\u53f3\u79fb\u4e00\u4f4d) // \u79fb\u52a8\u6709\u7b26\u53f7\u6574\u6570\u65f6\u8981\u5c0f\u5fc3 - \u4e0b\u9762\u8fd9\u4e9b\u5185\u5bb9\u65f6\u672a\u5b9a\u4e49\u7684: // - shifting into the sign bit of a signed integer (int a = 1 << 31) // - left-shifting a negative number (int a = -1 << 2) // - shifting by an offset which is >= the width of the type of the LHS: // int a = 1 << 32; // UB if int is 32 bits wide /////////////////////////////////////// // \u63a7\u5236\u7ed3\u6784 /////////////////////////////////////// if (0) { printf(\"I am never run\\n\"); } else if (0) { printf(\"I am also never run\\n\"); } else { printf(\"I print\\n\"); } // While \u5faa\u73af\u662f\u5b58\u5728\u7684 int ii = 0; while (ii < 10) { //\u4efb\u4f55\u5c0f\u4e8e 10 \u7684\u503c\u90fd\u4e3a\u771f printf(\"%d, \", ii++); // ii++ \u5728\u4f7f\u7528\u5176\u5f53\u524d\u503c\u540e\u589e\u52a0ii } // => prints \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \" printf(\"\\n\"); int kk = 0; do { printf(\"%d, \", kk); } while (++kk < 10); // ++kk \u5728\u4f7f\u7528\u5176\u5f53\u524d\u503c\u4e4b\u524d\u589e\u52a0ii // => prints \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \" printf(\"\\n\"); // For \u5faa\u73af\u4e5f\u4e00\u6837 int jj; for (jj=0; jj < 10; jj++) { printf(\"%d, \", jj); } // => prints \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \" printf(\"\\n\"); // *****NOTES*****: // \u5faa\u73af\u548c\u51fd\u6570\u5fc5\u987b\u6709\u4e00\u4e2a\u4e3b\u4f53\u3002\u5982\u679c\u4e0d\u9700\u8981\u4e3b\u4f53\u3002 int i; for (i = 0; i <= 5; i++) { ; // \u7528\u5206\u53f7\u4f5c\u4e3a\u4e3b\u4f53\uff08\u7a7a\u8bed\u53e5\uff09\u3002 } // Or for (i = 0; i <= 5; i++); // \u591a\u9009\u62e9\u5206\u652f: switch() switch (a) { case 0: // \u6807\u7b7e\u9700\u8981\u662f\u5b8c\u6574\u7684*\u5e38\u91cf*\u8868\u8fbe\u5f0f\uff08\u5982\u679a\u4e3e\uff09\u3002 printf(\"Hey, 'a' equals 0!\\n\"); break; // if you don't break, control flow falls over labels case 1: printf(\"Huh, 'a' equals 1!\\n\"); break; // Be careful - without a \"break\", execution continues until the // next \"break\" is reached. case 3: case 4: printf(\"Look at that.. 'a' is either 3, or 4\\n\"); break; default: // if `some_integral_expression` didn't match any of the labels fputs(\"Error!\\n\", stderr); exit(-1); break; } /* Using \"goto\" in C */ typedef enum { false, true } bool; // for C don't have bool as data type before C99 :( bool disaster = false; int i, j; for(i=0; i<100; ++i) for(j=0; j<100; ++j) { if((i + j) >= 150) disaster = true; if(disaster) goto error; // exit both for loops } error: // this is a label that you can \"jump\" to with \"goto error;\" printf(\"Error occurred at i = %d & j = %d.\\n\", i, j); /* https://ideone.com/GuPhd6 this will print out \"Error occurred at i = 51 & j = 99.\" */ /* it is generally considered bad practice to do so, except if you really know what you are doing. See https://en.wikipedia.org/wiki/Spaghetti_code#Meaning */ /////////////////////////////////////// // Typecasting /////////////////////////////////////// // Every value in C has a type, but you can cast one value into another type // if you want (with some constraints). int x_hex = 0x01; // You can assign vars with hex literals // binary is not in the standard, but allowed by some // compilers (x_bin = 0b0010010110) // Casting between types will attempt to preserve their numeric values printf(\"%d\\n\", x_hex); // => Prints 1 printf(\"%d\\n\", (short) x_hex); // => Prints 1 printf(\"%d\\n\", (char) x_hex); // => Prints 1 // If you assign a value greater than a types max val, it will rollover // without warning. printf(\"%d\\n\", (unsigned char) 257); // => 1 (Max char = 255 if char is 8 bits long) // For determining the max value of a `char`, a `signed char` and an `unsigned char`, // respectively, use the CHAR_MAX, SCHAR_MAX and UCHAR_MAX macros from <limits.h> // Integral types can be cast to floating-point types, and vice-versa. printf(\"%f\\n\", (double) 100); // %f always formats a double... printf(\"%f\\n\", (float) 100); // ...even with a float. printf(\"%d\\n\", (char)100.0); /////////////////////////////////////// // Pointers /////////////////////////////////////// // A pointer is a variable declared to store a memory address. Its declaration will // also tell you the type of data it points to. You can retrieve the memory address // of your variables, then mess with them. int x = 0; printf(\"%p\\n\", (void *)&x); // Use & to retrieve the address of a variable // (%p formats an object pointer of type void *) // => Prints some address in memory; // Pointers start with * in their declaration int *px, not_a_pointer; // px is a pointer to an int px = &x; // Stores the address of x in px printf(\"%p\\n\", (void *)px); // => Prints some address in memory printf(\"%zu, %zu\\n\", sizeof(px), sizeof(not_a_pointer)); // => Prints \"8, 4\" on a typical 64-bit system // To retrieve the value at the address a pointer is pointing to, // put * in front to dereference it. // Note: yes, it may be confusing that '*' is used for _both_ declaring a // pointer and dereferencing it. printf(\"%d\\n\", *px); // => Prints 0, the value of x // You can also change the value the pointer is pointing to. // We'll have to wrap the dereference in parenthesis because // ++ has a higher precedence than *. (*px)++; // Increment the value px is pointing to by 1 printf(\"%d\\n\", *px); // => Prints 1 printf(\"%d\\n\", x); // => Prints 1 // Arrays are a good way to allocate a contiguous block of memory int x_array[20]; //declares array of size 20 (cannot change size) int xx; for (xx = 0; xx < 20; xx++) { x_array[xx] = 20 - xx; } // Initialize x_array to 20, 19, 18,... 2, 1 // Declare a pointer of type int and initialize it to point to x_array int* x_ptr = x_array; // x_ptr now points to the first element in the array (the integer 20). // This works because arrays often decay into pointers to their first element. // For example, when an array is passed to a function or is assigned to a pointer, // it decays into (implicitly converted to) a pointer. // Exceptions: when the array is the argument of the `&` (address-of) operator: int arr[10]; int (*ptr_to_arr)[10] = &arr; // &arr is NOT of type `int *`! // It's of type \"pointer to array\" (of ten `int`s). // or when the array is a string literal used for initializing a char array: char otherarr[] = \"foobarbazquirk\"; // or when it's the argument of the `sizeof` or `alignof` operator: int arraythethird[10]; int *ptr = arraythethird; // equivalent with int *ptr = &arr[0]; printf(\"%zu, %zu\\n\", sizeof(arraythethird), sizeof(ptr)); // probably prints \"40, 4\" or \"40, 8\" // Pointers are incremented and decremented based on their type // (this is called pointer arithmetic) printf(\"%d\\n\", *(x_ptr + 1)); // => Prints 19 printf(\"%d\\n\", x_array[1]); // => Prints 19 // You can also dynamically allocate contiguous blocks of memory with the // standard library function malloc, which takes one argument of type size_t // representing the number of bytes to allocate (usually from the heap, although this // may not be true on e.g. embedded systems - the C standard says nothing about it). int *my_ptr = malloc(sizeof(*my_ptr) * 20); for (xx = 0; xx < 20; xx++) { *(my_ptr + xx) = 20 - xx; // my_ptr[xx] = 20-xx } // Initialize memory to 20, 19, 18, 17... 2, 1 (as ints) // Be careful passing user-provided values to malloc! If you want // to be safe, you can use calloc instead (which, unlike malloc, also zeros out the memory) int* my_other_ptr = calloc(20, sizeof(int)); // Note that there is no standard way to get the length of a // dynamically allocated array in C. Because of this, if your arrays are // going to be passed around your program a lot, you need another variable // to keep track of the number of elements (size) of an array. See the // functions section for more info. size_t size = 10; int *my_arr = calloc(size, sizeof(int)); // Add an element to the array size++; my_arr = realloc(my_arr, sizeof(int) * size); if (my_arr == NULL) { //Remember to check for realloc failure! return } my_arr[10] = 5; // Dereferencing memory that you haven't allocated gives // \"unpredictable results\" - the program is said to invoke \"undefined behavior\" printf(\"%d\\n\", *(my_ptr + 21)); // => Prints who-knows-what? It may even crash. // When you're done with a malloc'd block of memory, you need to free it, // or else no one else can use it until your program terminates // (this is called a \"memory leak\"): free(my_ptr); // Strings are arrays of char, but they are usually represented as a // pointer-to-char (which is a pointer to the first element of the array). // It's good practice to use `const char *' when referring to a string literal, // since string literals shall not be modified (i.e. \"foo\"[0] = 'a' is ILLEGAL.) const char *my_str = \"This is my very own string literal\"; printf(\"%c\\n\", *my_str); // => 'T' // This is not the case if the string is an array // (potentially initialized with a string literal) // that resides in writable memory, as in: char foo[] = \"foo\"; foo[0] = 'a'; // this is legal, foo now contains \"aoo\" function_1(); } // end main function /////////////////////////////////////// // Functions /////////////////////////////////////// // Function declaration syntax: // <return type> <function name>(<args>) int add_two_ints(int x1, int x2) { return x1 + x2; // Use return to return a value } /* Functions are call by value. When a function is called, the arguments passed to the function are copies of the original arguments (except arrays). Anything you do to the arguments in the function do not change the value of the original argument where the function was called. Use pointers if you need to edit the original argument values. Example: in-place string reversal */ // A void function returns no value void str_reverse(char *str_in) { char tmp; size_t ii = 0; size_t len = strlen(str_in); // `strlen()` is part of the c standard library // NOTE: length returned by `strlen` DOESN'T include the // terminating NULL byte ('\\0') for (ii = 0; ii < len / 2; ii++) { // in C99 you can directly declare type of `ii` here tmp = str_in[ii]; str_in[ii] = str_in[len - ii - 1]; // ii-th char from end str_in[len - ii - 1] = tmp; } } //NOTE: string.h header file needs to be included to use strlen() /* char c[] = \"This is a test.\"; str_reverse(c); printf(\"%s\\n\", c); // => \".tset a si sihT\" */ /* as we can return only one variable to change values of more than one variables we use call by reference */ void swapTwoNumbers(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } /* int first = 10; int second = 20; printf(\"first: %d\\nsecond: %d\\n\", first, second); swapTwoNumbers(&first, &second); printf(\"first: %d\\nsecond: %d\\n\", first, second); // values will be swapped */ // Return multiple values. // C does not allow for returning multiple values with the return statement. If // you would like to return multiple values, then the caller must pass in the // variables where they would like the returned values to go. These variables must // be passed in as pointers such that the function can modify them. int return_multiple( int *array_of_3, int *ret1, int *ret2, int *ret3) { if(array_of_3 == NULL) return 0; //return error code (false) //de-reference the pointer so we modify its value *ret1 = array_of_3[0]; *ret2 = array_of_3[1]; *ret3 = array_of_3[2]; return 1; //return error code (true) } /* With regards to arrays, they will always be passed to functions as pointers. Even if you statically allocate an array like `arr[10]`, it still gets passed as a pointer to the first element in any function calls. Again, there is no standard way to get the size of a dynamically allocated array in C. */ // Size must be passed! // Otherwise, this function has no way of knowing how big the array is. void printIntArray(int *arr, size_t size) { int i; for (i = 0; i < size; i++) { printf(\"arr[%d] is: %d\\n\", i, arr[i]); } } /* int my_arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; int size = 10; printIntArray(my_arr, size); // will print \"arr[0] is: 1\" etc */ // if referring to external variables outside function, you should use the extern keyword. int i = 0; void testFunc() { extern int i; //i here is now using external variable i } // make external variables private to source file with static: static int j = 0; //other files using testFunc2() cannot access variable j void testFunc2() { extern int j; } // The static keyword makes a variable inaccessible to code outside the // compilation unit. (On almost all systems, a \"compilation unit\" is a .c // file.) static can apply both to global (to the compilation unit) variables, // functions, and function-local variables. When using static with // function-local variables, the variable is effectively global and retains its // value across function calls, but is only accessible within the function it // is declared in. Additionally, static variables are initialized to 0 if not // declared with some other starting value. //**You may also declare functions as static to make them private** /////////////////////////////////////// // User-defined types and structs /////////////////////////////////////// // Typedefs can be used to create type aliases typedef int my_type; my_type my_type_var = 0; // Structs are just collections of data, the members are allocated sequentially, // in the order they are written: struct rectangle { int width; int height; }; // It's not generally true that // sizeof(struct rectangle) == sizeof(int) + sizeof(int) // due to potential padding between the structure members (this is for alignment // reasons). [1] void function_1() { struct rectangle my_rec; // Access struct members with . my_rec.width = 10; my_rec.height = 20; // You can declare pointers to structs struct rectangle *my_rec_ptr = &my_rec; // Use dereferencing to set struct pointer members... (*my_rec_ptr).width = 30; // ... or even better: prefer the -> shorthand for the sake of readability my_rec_ptr->height = 10; // Same as (*my_rec_ptr).height = 10; } // You can apply a typedef to a struct for convenience typedef struct rectangle rect; int area(rect r) { return r.width * r.height; } // if you have large structs, you can pass them \"by pointer\" to avoid copying // the whole struct: int areaptr(const rect *r) { return r->width * r->height; } /////////////////////////////////////// // Function pointers /////////////////////////////////////// /* At run time, functions are located at known memory addresses. Function pointers are much like any other pointer (they just store a memory address), but can be used to invoke functions directly, and to pass handlers (or callback functions) around. However, definition syntax may be initially confusing. Example: use str_reverse from a pointer */ void str_reverse_through_pointer(char *str_in) { // Define a function pointer variable, named f. void (*f)(char *); // Signature should exactly match the target function. f = &str_reverse; // Assign the address for the actual function (determined at run time) // f = str_reverse; would work as well - functions decay into pointers, similar to arrays (*f)(str_in); // Just calling the function through the pointer // f(str_in); // That's an alternative but equally valid syntax for calling it. } /* As long as function signatures match, you can assign any function to the same pointer. Function pointers are usually typedef'd for simplicity and readability, as follows: */ typedef void (*my_fnp_type)(char *); // Then used when declaring the actual pointer variable: // ... // my_fnp_type f; ///////////////////////////// // Printing characters with printf() ///////////////////////////// //Special characters: /* '\\a'; // alert (bell) character '\\n'; // newline character '\\t'; // tab character (left justifies text) '\\v'; // vertical tab '\\f'; // new page (form feed) '\\r'; // carriage return '\\b'; // backspace character '\\0'; // NULL character. Usually put at end of strings in C. // hello\\n\\0. \\0 used by convention to mark end of string. '\\\\'; // backslash '\\?'; // question mark '\\''; // single quote '\\\"'; // double quote '\\xhh'; // hexadecimal number. Example: '\\xb' = vertical tab character '\\0oo'; // octal number. Example: '\\013' = vertical tab character //print formatting: \"%d\"; // integer \"%3d\"; // integer with minimum of length 3 digits (right justifies text) \"%s\"; // string \"%f\"; // float \"%ld\"; // long \"%3.2f\"; // minimum 3 digits left and 2 digits right decimal float \"%7.4s\"; // (can do with strings too) \"%c\"; // char \"%p\"; // pointer. NOTE: need to (void *)-cast the pointer, before passing // it as an argument to `printf`. \"%x\"; // hexadecimal \"%o\"; // octal \"%%\"; // prints % */ /////////////////////////////////////// // Order of Evaluation /////////////////////////////////////// // From top to bottom, top has higher precedence //---------------------------------------------------// // Operators | Associativity // //---------------------------------------------------// // () [] -> . | left to right // // ! ~ ++ -- + = *(type) sizeof | right to left // // * / % | left to right // // + - | left to right // // << >> | left to right // // < <= > >= | left to right // // == != | left to right // // & | left to right // // ^ | left to right // // | | left to right // // && | left to right // // || | left to right // // ?: | right to left // // = += -= *= /= %= &= ^= |= <<= >>= | right to left // // , | left to right // //---------------------------------------------------// /******************************* Header Files ********************************** Header files are an important part of C as they allow for the connection of C source files and can simplify code and definitions by separating them into separate files. Header files are syntactically similar to C source files but reside in \".h\" files. They can be included in your C source file by using the precompiler command #include \"example.h\", given that example.h exists in the same directory as the C file. */ /* A safe guard to prevent the header from being defined too many times. This */ /* happens in the case of circle dependency, the contents of the header is */ /* already defined. */ #ifndef EXAMPLE_H /* if EXAMPLE_H is not yet defined. */ #define EXAMPLE_H /* Define the macro EXAMPLE_H. */ /* Other headers can be included in headers and therefore transitively */ /* included into files that include this header. */ #include <string.h> /* Like for c source files, macros can be defined in headers */ /* and used in files that include this header file. */ #define EXAMPLE_NAME \"Dennis Ritchie\" /* Function macros can also be defined. */ #define ADD(a, b) ((a) + (b)) /* Notice the parenthesis surrounding the arguments -- this is important to */ /* ensure that a and b don't get expanded in an unexpected way (e.g. consider */ /* MUL(x, y) (x * y); MUL(1 + 2, 3) would expand to (1 + 2 * 3), yielding an */ /* incorrect result) */ /* Structs and typedefs can be used for consistency between files. */ typedef struct Node { int val; struct Node *next; } Node; /* So can enumerations. */ enum traffic_light_state {GREEN, YELLOW, RED}; /* Function prototypes can also be defined here for use in multiple files, */ /* but it is bad practice to define the function in the header. Definitions */ /* should instead be put in a C file. */ Node createLinkedList(int *vals, int len); /* Beyond the above elements, other definitions should be left to a C source */ /* file. Excessive includes or definitions should, also not be contained in */ /* a header file but instead put into separate headers or a C file. */ #endif /* End of the if precompiler directive. */","title":"C"},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Cpp/","text":"","title":"Cpp"},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/","text":"","title":"Go"},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/","text":"","title":"Java"},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/","text":"","title":"Python"}]}